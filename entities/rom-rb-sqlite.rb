
require "rom-sql"
require "sqlite3"

setup = ROM.setup(:sql, "sqlite::memory")
setup.default.connection.create_table(:users) do
  primary_key :id
  String :name
  Boolean :admin
  Float :number
end

setup.default.connection.create_table(:tasks) do
  primary_key :id
  Integer :user_id
  String :title
end

# our PORO, used to hold the data, this is actually optional as ROM can create it for us,
# especially if it is only used to hold data
class User
  attr_accessor :tasks
  attr_reader :name, :number

  def initialize(attributes)
    @name, @number, @tasks = attributes.values_at(:name, :number, :tasks)
  end
end

# A Relation for users, basically the firsst step after the database, used to load
# the data from the database
class Users < ROM::Relation[:sql]
  one_to_many :tasks, key: :user_id

  # scopes
  def by_name(name)
    where(name: name)
  end

  # actual join, you only get the tasks from the db when actually adding this scope,
  # e.g. rom.relation(:users).with_tasks.as(:model)
  def with_tasks
    association_join(:tasks, select: [:title])
  end
end

# a relation for tasks
class Tasks < ROM::Relation[:sql]
end

# the second step after the DB is to use a mapper for the relation:
# DB -> relation -> specific mapper
class UserMapper < ROM::Mapper
  relation :users

  # this is an arbitrary name given
  # could also be "foobar" and affects the way "as" can be called on the relation
  register_as :model

  model User # user the PORO defined earlier

  group tasks: [:title]
end

class TaskMapper < ROM::Mapper
  relation :tasks
  register_as :model

  model name: 'Task' # the PORO here is autogenerated by the finalization of the setup
end

# withou this, nothing happens
rom = ROM.finalize.env

users = rom.relations.users
tasks = rom.relations.tasks

100.times do |n|
  users.insert(id: n, name: "Piotr", number: n * 1.2)
end

# add one task for the first user.
tasks.insert(user_id: 1, title: "Be happy")

# create a PORO that will hold actual functionality on th data, explicitly
# separating the business logic from the data
class AwesomeUserBusinessLogic
  def initialize(users)
    @users = users
  end

  def self.result(users)
    # actually call `number` on each user
    users.map(&:number).map do |n|
      calculate n
    end.inject(:+)
  end

  private

  # secret sauce magik
  def self.calculate(number)
    number + 2
  end
end

# fetch all the users into a relation (to_a forces a load)
# not the as(:model) actually represents the set as a set of Users
# (see UserMapper).
# The result we want is the set on the data
result_users = rom.relation(:users).as(:model).to_a
AwesomeUserBusinessLogic.result(result_users)

# Important: The result_users above do _not_ include the tasks
# If the tasks should be added should be added, they have to be included
# in the relation:
result_users = rom.relation(:users).with_tasks.as(:model).to_a # Array of User POROs with tasks attached

# If the as(:model) call would have been omitted, the data usually gets represented as a hash
# which can be useful, as object generation is costly
result_users = rom.relation(:users) # => Array of hashes
